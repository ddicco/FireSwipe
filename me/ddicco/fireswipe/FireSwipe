package me.ddicco.fireswipe;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;

import com.projectkorra.projectkorra.GeneralMethods;
import com.projectkorra.projectkorra.ProjectKorra;
import com.projectkorra.projectkorra.ability.AddonAbility;
import com.projectkorra.projectkorra.ability.ElementalAbility;
import com.projectkorra.projectkorra.ability.FireAbility;
import com.projectkorra.projectkorra.util.DamageHandler;
import com.projectkorra.projectkorra.util.ParticleEffect;

public class FireSwipe extends FireAbility implements AddonAbility {
	
	private double damage;
	private double range;
	private double speed;
	private float particlespeed;
	private double radius;
	Location startlocation;
	private int arc;
	private int particles;
	private long cooldown;
	private Map<Vector, Location> elements;
	private double stepSize;

	public FireSwipe(Player player) {
		super(player);
		// TODO Auto-generated constructor stub
		
		startlocation = player.getEyeLocation();
		particles = 3;
		particlespeed = 0.1F;
		arc = 15;
		stepSize = 3;
		cooldown = 5000;
		damage = 3;
		speed = 25 * (ProjectKorra.time_step / 1000.0);
		range = 8;
		radius = 3;
		elements = new ConcurrentHashMap<>();
		
		if(bPlayer.isOnCooldown(this)) {
			remove();
			return;
		}
		
		if(!bPlayer.canBend(this)) {
			remove();
			return;
		}
		
		setFields();
		
		start();
	}
	
	public void setFields() {
		bPlayer.addCooldown(this);
		startlocation = this.player.getEyeLocation();
		for (double i = -this.arc; i <= this.arc; i += this.stepSize) {
			final double angle = Math.toRadians(i);
			final Vector direction = this.player.getEyeLocation().getDirection().clone();

			double x, z, vx, vz;
			x = direction.getX();
			z = direction.getZ();

			vx = x * Math.cos(angle) - z * Math.sin(angle);
			vz = x * Math.sin(angle) + z * Math.cos(angle);

			direction.setX(vx);
			direction.setZ(vz);
			
			this.elements.put(direction, startlocation);
		}
	}
	
	
	
	private void damageEntities(Location location2, Vector direction2) {
		// TODO Auto-generated method stub
	}

	@Override
	public long getCooldown() {
		// TODO Auto-generated method stub
		return cooldown;
	}
	
	@Override
	public Location getLocation() {
		// TODO Auto-generated method stub
		return player.getLocation();
	}

	@Override
	public String getName() {
		// TODO Auto-generated method stub
		return "FireSwipe";
	}

	@Override
	public boolean isHarmlessAbility() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean isSneakAbility() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void progress() {
		// TODO Auto-generated method stub
		if(!bPlayer.canBendIgnoreBindsCooldowns(this)) {
			remove();
			return;
		}
		
		if(!player.isOnline() || player.isDead()) {
			remove();
			return;
		}
		
		if (this.elements.isEmpty()) {
			remove();
			return;
		}
		for (final Vector direction : this.elements.keySet()) {
			Location location = this.elements.get(direction);
			if (direction != null && location != null) {
				location = location.clone().add(direction.clone().multiply(this.speed));
				this.elements.put(direction, location);

				if (location.distanceSquared(startlocation) > this.range * this.range || GeneralMethods.isRegionProtectedFromBuild(this, location)) {
					elements.clear();
				} else {
					final Block block = location.getBlock();
					if (!ElementalAbility.isTransparent(this.player, block)) {
						remove();
						return;
					}

					if (block.getType() != Material.AIR) {
						if (block.getType().equals(Material.SNOW)) {
							continue;
						} else {
							elements.remove(direction);
						}
					} else {
						ParticleEffect.FLAME.display(location, 0.2F, 0.2F, 0.2F, particlespeed, particles);
						damageEntities(location, direction);
				        for ( Entity entity : GeneralMethods.getEntitiesAroundPoint(location, radius) ) {
				            if(entity instanceof LivingEntity) {
				            	if(entity != player) {
				                   	DamageHandler.damageEntity(entity, damage, this);
				            	}
				            }
				        }
					}
				}
			}
		}
	}

	@Override
	public String getAuthor() {
		// TODO Auto-generated method stub
		return "ddicco";
	}

	@Override
	public String getVersion() {
		// TODO Auto-generated method stub
		return "1.0";
	}

	@Override
	public void load() {
		// TODO Auto-generated method stub
		ProjectKorra.plugin.getServer().getPluginManager().registerEvents(new FireSwipeListener(), ProjectKorra.plugin);
		ProjectKorra.log.info("Successfully enabled " + getName() + " by " + getAuthor() + " Version " + getVersion());
	}
	
	@Override
	public void stop() {
		// TODO Auto-generated method stub
		
	}
}
